> DATA: 2025-07-10 00:20
> TAGS: [[数据结构]]
> Course: #比特数据结构 
> Author: [ApolloMonasa](https://github.com/ApolloMonasa)
> Pre: 
> Next:

# 1.2 空间复杂度
> [!NOTE] 核心定义
> **空间复杂度 (Space Complexity)**，记作 `S(n)`，衡量的是一个算法在执行过程中临时占用的**额外存储空间**与输入规模 `n` 之间的增长关系。它关注的是“除了输入数据之外，你的算法还需要多少工作台面”。

## 1. 引入：为什么要关心空间复杂度？

在内存非常宝贵的时代（如嵌入式系统、早期计算机），空间复杂度是决定一个算法是否可行的关键因素。如今，虽然硬件内存变得充裕，但对于处理海量数据（大数据、云计算）的场景，空间复杂度依然至关重要。一个 `S(n^2)` 的算法在处理大规模数据时可能会轻易耗尽服务器内存。

此外，理解空间复杂度有助于我们深入分析**递归**算法的开销，并掌握**时间与空间权衡**这一核心编程思想。

## 2. 内容：计算什么？

> [!IMPORTANT] 空间复杂度的计算范围
> 我们通常只计算**辅助空间 (Auxiliary Space)**，即算法为了运行而额外创建的变量和数据结构所占用的空间。我们**不**计算输入数据本身占用的空间。

一个算法的总空间占用包括：
1.  **输入空间**：存储输入数据所需的空间。（通常不计入空间复杂度）
2.  **指令空间**：存储编译后的程序代码所需的空间。（通常是固定的，不计入）
3.  **辅助空间**：算法运行时额外使用的空间。**这是我们分析的重点**。

### 辅助空间的组成
- **变量和数据结构**: 算法内部创建的各种变量、数组、对象等。
- **递归调用栈 (Recursion Stack)**: 这是分析递归算法空间复杂度的关键。每一次函数调用都会在调用栈上创建一个“栈帧 (Stack Frame)”，用于存储函数的参数、局部变量和返回地址。递归的最大深度决定了调用栈所占用的空间。

## 3. 常见空间复杂度示例

| 复杂度 (Big O) | 名称 | 描述 | 简单代码示例 (Python) |
| :--- | :--- | :--- | :--- |
| **S(1)** | **常数空间** | 算法所需的额外空间是固定的，不随 `n` 变化。 | `def swap(a, b):`<br>&emsp;`temp = a`<br>&emsp;`a = b`<br>&emsp;`b = temp`<br>*(只用了一个额外变量 `temp`)* |
| **S(log n)** | **对数空间** | 通常出现在递归算法中，递归深度为 `log n`。 | `def binary_search_recursive(arr, l, r, x):`<br>&emsp;`...`<br>*(递归栈的最大深度为 O(log n))* |
| **S(n)** | **线性空间** | 需要一个与输入规模 `n` 成正比的额外空间。 | `def copy_array(arr):`<br>&emsp;`new_arr = [0] * len(arr)`<br>&emsp;`for i in range(len(arr)):`<br>&emsp;&emsp;`new_arr[i] = arr[i]`<br>*(创建了一个大小为 n 的新数组)* |
| **S(n²)** | **平方空间** | 需要一个 `n x n` 的二维数据结构，或类似规模的空间。 | `def create_matrix(n):`<br>&emsp;`matrix = [[0 for _ in range(n)] for _ in range(n)]`<br>*(创建了一个 n*n 的邻接矩阵)* |

---

## 4. 时间与空间的权衡 (Time-Space Trade-off)

这是一个在算法设计中永恒的主题。

> [!QUOTE] "You can often make an algorithm faster by using more memory, or save memory by accepting a slower execution time."
> “你常常可以通过使用更多内存来让算法更快，或者通过接受更长的执行时间来节省内存。”

**经典示例：查找数组中的重复元素**
假设有一个包含 `n` 个数字的数组。

- **方案一 (省空间，费时间)**
    - **思路**: 使用两层嵌套循环。外层循环遍历每个元素，内层循环检查该元素是否在后面出现过。
    - **时间复杂度**: O(n²)
    - **空间复杂度**: O(1) (只需要几个额外的指针变量)

- **方案二 (费空间，省时间)**
    - **思路**: 创建一个哈希集合 (Hash Set)。遍历数组，对于每个元素，先检查它是否已在哈希集合中。如果在，则找到重复；如果不在，则将其加入哈希集合。
    - **时间复杂度**: O(n) (每次哈希表操作的平均时间是 O(1))
    - **空间复杂度**: O(n) (在最坏情况下，哈希集合需要存储所有 `n` 个元素)

这就是一次典型的时间-空间权衡：我们用 O(n) 的额外空间，将时间复杂度从 O(n²) 优化到了 O(n)。

## 5. 关联与参考

- 空间复杂度的分析方法与 [[时间复杂度]] 的分析方法（如大O表示法）是相同的。
- 对于[[分治算法]]和[[递归]]，空间复杂度的分析尤其重要，因为它涉及到对递归栈深度的评估。
- 空间复杂度是评估[[数据结构]]效率的重要维度之一。

## Reference

- [[算法导论]] (CLRS)
- 各大高校的算法与数据结构课程材料。
---
Recommend Links

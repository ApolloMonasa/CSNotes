> DATA: 2025-06-19 17:51
> TAGS: [[离散数学]]
> Course: #离散数学 
> Author: [ApolloMonasa](https://github.com/ApolloMonasa)
> Pre: 




# 标准范式

## 作业

![[离散Homework1.4.png]]


好的，我们来深入探讨范式中的“标准型”——**标准析取范式（主析取范式）** 和 **标准合取范式（主合取范式）**。它们是普通范式的“终极形态”，具有**唯一性**，因此也被称为**典范式（Canonical Form）**。

### **核心升级：从范式到标准范式**

*   **范式 (Normal Form)**: 一种标准化的结构，如“积之和”(DNF) 或“和之积”(CNF)。一个公式可以有多种等价的范式。
*   **标准范式 (Standard/Principal Normal Form)**: 一种**唯一的**、更加精细的范式。它要求构成范式的每个基本项（初等积/初等和）都必须包含**所有**的命题变元。

为了定义标准范式，我们必须先精确定义其构件：**最小项**和**最大项**。

---

### **1. 构件升级：最小项与最大项**

假设我们讨论的命题公式中包含了 `n` 个命题变元（例如 `P, Q, R`，则 `n=3`）。

#### **最小项 (Minterm)**

*   **定义**: 最小项是一个特殊的**初等积**，它包含了**全部 `n` 个命题变元**，每个变元或其否定形式**恰好出现一次**。
*   **性质**:
    1.  **数量**: 对于 `n` 个变元，总共有 `2^n` 个不同的最小项。
    2.  **唯一为真**: 每个最小项只在**一种**真值指派下为真（True/1）。其他 `2^n - 1` 种情况下均为假。
    3.  **互斥性**:任意两个不同的最小项的合取（`m_i ∧ m_j` 当 `i ≠ j`）恒为假。
    4.  **完备性**: 所有 `2^n` 个最小项的析取（`m_0 ∨ m_1 ∨ ...`）恒为真。
*   **表示法**:
    *   我们用 `m_i` 来表示第 `i` 个最小项。`i` 的二进制形式决定了每个变元的形态。
    *   **规则**: 在变元的标准次序下（如 `P, Q, R`），如果 `i` 的二进制表示中对应位为 **1**，则取**原变元**；如果为 **0**，则取**否定形式**。

*   **示例 (n=3, 变元 P, Q, R)**:

| 下标 `i` | 二进制(PQR) | 最小项 `m_i` |
| :--- | :--- | :--- |
| 0 | 000 | `¬P ∧ ¬Q ∧ ¬R` |
| 1 | 001 | `¬P ∧ ¬Q ∧ R` |
| 2 | 010 | `¬P ∧ Q ∧ ¬R` |
| 3 | 011 | `¬P ∧ Q ∧ R` |
| 4 | 100 | `P ∧ ¬Q ∧ ¬R` |
| 5 | 101 | `P ∧ ¬Q ∧ R` |
| 6 | 110 | `P ∧ Q ∧ ¬R` |
| 7 | 111 | `P ∧ Q ∧ R` |

例如，`m_5` 对应二进制 `101`，所以是 `P ∧ ¬Q ∧ R`。只有当 `P=1, Q=0, R=1` 时，`m_5` 的值才为 `1`。

#### **最大项 (Maxterm)**

*   **定义**: 最大项是一个特殊的**初等和**，它包含了**全部 `n` 个命题变元**，每个变元或其否定形式**恰好出现一次**。
*   **性质**:
    1.  **数量**: 对于 `n` 个变元，总共有 `2^n` 个不同的最大项。
    2.  **唯一为假**: 每个最大项只在**一种**真值指派下为假（False/0）。其他 `2^n - 1` 种情况下均为真。
    3.  **对偶关系**: 最小项和最大项存在优美的对偶关系：**`¬m_i ⇔ M_i`** 以及 **`¬M_i ⇔ m_i`**。这意味着，使 `m_i` 为真的那行赋值，恰好是使 `M_i` 为假的那行赋值。
*   **表示法**:
    *   我们用 `M_i` 来表示第 `i` 个最大项。`i` 的二进制形式也决定了每个变元的形态。
    *   **规则 (与最小项相反)**: 在变元的标准次序下，如果 `i` 的二进制表示中对应位为 **0**，则取**原变元**；如果为 **1**，则取**否定形式**。

*   **示例 (n=3, 变元 P, Q, R)**:

| 下标 `i` | 二进制(PQR) | 最大项 `M_i` |
| :--- | :--- | :--- |
| 0 | 000 | `P ∨ Q ∨ R` |
| 1 | 001 | `P ∨ Q ∨ ¬R` |
| 2 | 010 | `P ∨ ¬Q ∨ R` |
| 3 | 011 | `P ∨ ¬Q ∨ ¬R` |
| 4 | 100 | `¬P ∨ Q ∨ R` |
| 5 | 101 | `¬P ∨ Q ∨ ¬R` |
| 6 | 110 | `¬P ∨ ¬Q ∨ R` |
| 7 | 111 | `¬P ∨ ¬Q ∨ ¬R` |

例如，`M_5` 对应二进制 `101`，所以是 `¬P ∨ Q ∨ ¬R`。只有当 `P=1, Q=0, R=1` 时，`M_5` 的值才为 `0`。

---

### **2. 标准析取范式 (Principal DNF, PDNF)**

也称为**主析取范式**。

*   **定义**: 由**有限个最小项**通过**析取 (∨)** 联结而成的公式。
*   **结构**: "最小项 之和"。
*   **唯一性**: 任何一个非永假式的命题公式，其标准析取范式是**唯一**的。
*   **表示法**: `∑m(i, j, k, ...)`，其中 `i, j, k` 是构成范式的最小项的下标。

#### **求法**

1.  **真值表法 (首选方法)**:
    1.  列出公式的完整真值表。
    2.  找出所有使公式结果为 **真 (1)** 的行。
    3.  记下这些行的下标 `i, j, k, ...`。
    4.  写出对应的最小项 `m_i, m_j, m_k, ...`。
    5.  将这些最小项用析取 `∨` 连接起来，即为 `m_i ∨ m_j ∨ m_k ∨ ...`。

2.  **等价演算法**:
    1.  先求出任意一个析取范式 (DNF)。
    2.  对 DNF 中的每一个初等积，补全其缺失的变元。方法是：如果缺少变元 `R`，则将该项 `T` 乘以 `(R ∨ ¬R)`，即 `T ∧ (R ∨ ¬R)`，然后利用分配律展开。
    3.  重复此过程，直到所有项都成为最小项。
    4.  利用幂等律 `A ∨ A ⇔ A` 删除重复的最小项。

#### **应用**

*   **判断公式等价性**: 两个公式等价，当且仅当它们的标准析取范式完全相同。
*   **数字电路设计**: PDNF 直接对应于电路的“**与-或**”(AND-OR)实现，即所谓的**积之和 (Sum of Products, SOP)** 形式，是可编程逻辑阵列(PLA)的基础。
*   **判断公式类型**:
    *   如果一个公式的PDNF包含了所有 `2^n` 个最小项，则该公式是**永真式**。
    *   如果一个公式的PDNF为空（即真值表中没有 `1`），则该公式是**永假式**。

---

### **3. 标准合取范式 (Principal CNF, PCNF)**

也称为**主合取范式**。

*   **定义**: 由**有限个最大项**通过**合取 (∧)** 联结而成的公式。
*   **结构**: "最大项 之积"。
*   **唯一性**: 任何一个非永真式的命题公式，其标准合取范式是**唯一**的。
*   **表示法**: `∏M(i, j, k, ...)`，其中 `i, j, k` 是构成范式的最大项的下标。

#### **求法**

1.  **真值表法 (首选方法)**:
    1.  列出公式的完整真值表。
    2.  找出所有使公式结果为 **假 (0)** 的行。
    3.  记下这些行的下标 `i, j, k, ...`。
    4.  写出对应的最大项 `M_i, M_j, M_k, ...`。
    5.  将这些最大项用合取 `∧` 连接起来，即为 `M_i ∧ M_j ∧ M_k ∧ ...`。

2.  **等价演算法**:
    1.  先求出任意一个合取范式 (CNF)。
    2.  对 CNF 中的每一个初等和，补全其缺失的变元。方法是：如果缺少变元 `R`，则将该项 `T` 加上 `(R ∧ ¬R)`（因为 `A ∨ False ⇔ A`），即 `T ∨ (R ∧ ¬R)`，然后利用分配律展开。
    3.  重复此过程，直到所有项都成为最大项。
    4.  利用幂等律 `A ∧ A ⇔ A` 删除重复的最大项。

#### **应用**

*   **判断公式等价性**: 同样，两个公式等价当且仅当其PCNF相同。
*   **自动推理与SAT问题**: 许多自动定理证明器，特别是基于**归结原理 (Resolution Principle)** 的系统，都要求输入是合取范式。**SAT (Satisfiability) 问题**，即判断一个命题公式是否可满足，其核心就是处理 CNF 形式。
*   **数字电路设计**: PCNF 直接对应于电路的“**或-与**”(OR-AND)实现，即所谓的**和之积 (Product of Sums, POS)** 形式。
*   **判断公式类型**:
    *   如果一个公式的PCNF为空（即真值表中没有 `0`），则该公式是**永真式**。
    *   如果一个公式的PCNF包含了所有 `2^n` 个最大项，则该公式是**永假式**。

---

### **4. 例题：求 `F = (P ∧ Q) → R` 的标准范式**

变元为 `P, Q, R` (`n=3`)。

#### **解法一：真值表法**

1.  **列出真值表**:

| 下标 `i` | P | Q | R | `P ∧ Q` | **F = (P ∧ Q) → R** |
| :--- | :-- | :-- | :-- | :--- | :------------------- |
| 0 | 0 | 0 | 0 | 0 | **1** |
| 1 | 0 | 0 | 1 | 0 | **1** |
| 2 | 0 | 1 | 0 | 0 | **1** |
| 3 | 0 | 1 | 1 | 0 | **1** |
| 4 | 1 | 0 | 0 | 0 | **1** |
| 5 | 1 | 0 | 1 | 0 | **1** |
| 6 | 1 | 1 | 0 | 1 | **0** |
| 7 | 1 | 1 | 1 | 1 | **1** |

2.  **求标准析取范式 (PDNF)**:
    *   找出 `F=1` 的行，下标为: 0, 1, 2, 3, 4, 5, 7。
    *   对应的最小项为: `m_0, m_1, m_2, m_3, m_4, m_5, m_7`。
    *   **PDNF**: `(¬P∧¬Q∧¬R) ∨ (¬P∧¬Q∧R) ∨ (¬P∧Q∧¬R) ∨ (¬P∧Q∧R) ∨ (P∧¬Q∧¬R) ∨ (P∧¬Q∧R) ∨ (P∧Q∧R)`
    *   **简洁表示**: `∑m(0, 1, 2, 3, 4, 5, 7)`

3.  **求标准合取范式 (PCNF)**:
    *   找出 `F=0` 的行，下标为: 6。
    *   对应的最大项为: `M_6`。
    *   `M_6` 对应二进制 `110`，其公式为 `¬P ∨ ¬Q ∨ R`。
    *   **PCNF**: `¬P ∨ ¬Q ∨ R`
    *   **简洁表示**: `∏M(6)`

#### **解法二：等价演算法**

`F = (P ∧ Q) → R`

1.  **去蕴含**: `F ⇔ ¬(P ∧ Q) ∨ R`
2.  **内移否定**: `F ⇔ (¬P ∨ ¬Q) ∨ R`
3.  **去括号**: `F ⇔ ¬P ∨ ¬Q ∨ R`

我们得到了一个简单的表达式 `¬P ∨ ¬Q ∨ R`。

*   **求 PCNF**:
    *   `¬P ∨ ¬Q ∨ R` 本身就是一个初等和，且包含了所有变元 `P, Q, R`。因此，它就是一个最大项。
    *   它是哪个最大项？`¬P` (1), `¬Q` (1), `R` (0) -> 对应二进制 `110` -> `M_6`。
    *   所以 **PCNF** 就是 `M_6`，即 `¬P ∨ ¬Q ∨ R`。这与真值表法结果一致，并且快得多。

*   **求 PDNF (从PCNF出发)**:
    *   我们知道公式的 PCNF 是 `∏M(6)`。
    *   这意味着公式在除了第6行以外的所有行都为真。
    *   所以 PDNF 就是由除了 `m_6` 以外的所有最小项构成的。
    *   即 **PDNF** 是 `∑m(0, 1, 2, 3, 4, 5, 7)`。这同样与真值表法结果一致。

这个例子展示了，有时等价演算可以非常迅速地得到一个简单的范式，然后利用其与标准范式的关系，直接推导出两种标准0范式。

# Reference
 

---
Recommend Links
[[2.8最小项]]
[[2.9最大项]]


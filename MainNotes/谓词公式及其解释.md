

> DATA: 2025-06-20 20:27
> TAGS: [[离散数学]]
> Course: #离散数学
> Author: [ApolloMonasa](https://github.com/ApolloMonasa)
> Pre:

# 谓词公式及其解释

谓词逻辑（Predicate Logic），也称为一阶逻辑（First-Order Logic），是命题逻辑的扩展。它引入了量词、谓词和个体，使其能够表达更复杂的语句和推理，例如关于对象属性和对象之间关系的命题。

## 定义

### 项 (Term)
项是谓词逻辑中代表个体的表达式，可以看作是句子中的“名词”或“代词”。项被递归地定义如下：
1.  **个体常量 (Constant)**：表示具体、确定的个体。例如：`a`, `b`, `0`, `苏格拉底`。
2.  **个体变元 (Variable)**：表示不确定的、任意的个体。例如：`x`, `y`, `z`。
3.  **函数 (Function)**：如果 `f` 是一个 n 元函数符号，`t₁, t₂, ..., tₙ` 是项，则 `f(t₁, t₂, ..., tₙ)` 也是一个项。例如：`plus(x, y)`, `father(John)`。

### 原子公式 (Atomic Formula)
原子公式是谓词逻辑中最基本的陈述单元，它断言个体之间存在某种关系或个体具有某种性质。
- 如果 `P` 是一个 n 元谓词符号，`t₁, t₂, ..., tₙ` 是项，那么 `P(t₁, t₂, ..., tₙ)` 就是一个原子公式。
- **示例**：
    - `Loves(x, y)`: x 爱 y
    - `IsMan(Socrates)`: 苏格拉底是人
    - `Greater(x, 5)`: x 大于 5

### 谓词公式 (Predicate Formula / Well-formed Formula, WFF)
谓词公式是按照特定规则由原子公式、逻辑联结词和量词构成的合法表达式。其递归定义如下：
1.  任何原子公式都是一个谓词公式。
2.  如果 `A` 是一个谓词公式，那么 `(¬A)` 也是一个谓词公式。
3.  如果 `A` 和 `B` 是谓词公式，那么 `(A ∧ B)`, `(A ∨ B)`, `(A → B)`, `(A ↔ B)` 也是谓词公式。
4.  如果 `A` 是一个谓词公式，`x` 是一个体变元，那么 `(∀x A)` 和 `(∃x A)` 也是谓词公式。
    - `∀`: 全称量词 (For all)，表示“对所有的”、“每一个”。
    - `∃`: 存在量词 (There exists)，表示“存在一个”、“至少有一个”。

### 指导变元 (Guiding Variable)
在量词 `∀x` 和 `∃x` 中，变元 `x` 被称为指导变元。

### 辖域 (Scope)
量词的作用范围称为其辖域。在公式 `(∀x A)` 或 `(∃x A)` 中，子公式 `A` 就是量词的辖域。
- **示例**：在 `(∀x (P(x) → Q(x))) ∧ R(y)` 中，`∀x` 的辖域是 `(P(x) → Q(x))`。

### 约束变元 (Bound Variable)
如果变元 `x` 的一次出现是在量词 `∀x` 或 `∃x` 的辖域内，那么这次出现的 `x` 就是一个**约束变元**（被该量词约束）。

### 自由变元 (Free Variable)
如果变元 `x` 的一次出现不是约束变元，那么它就是**自由变元**。
- **示例**：在公式 `(∀x (P(x, y))) ∨ Q(x)` 中：
    - `P(x, y)` 中的 `x` 是约束变元，被 `∀x` 约束。
    - `y` 是自由变元。
    - `Q(x)` 中的 `x` 是自由变元，因为它不在 `∀x` 的辖域内。

### 闭式 (Closed Formula / Sentence)
一个不含任何自由变元的谓词公式称为闭式。只有闭式才能在给定的解释下被赋予一个确定的真值（真或假）。
- **示例**：
    - `∀x ∃y Loves(x, y)` 是一个闭式。
    - `∃y Loves(x, y)` 不是闭式（`x` 是自由的）。

### 谓词公式的解释 (Interpretation)
一个解释（或模型）`I` 为谓词公式提供了具体的含义，它由以下三部分组成：
1.  **论域 (Domain of Discourse) D**：一个非空的个体集合，是所有变元和常量的取值范围。
2.  **常量赋值**：为每个个体常量 `c` 指定 `D` 中的一个元素 `c_I`。
3.  **谓词和函数赋值**：
    - 为每个 n 元谓词 `P` 指定 `D` 上的一个 n 元关系 `P_I subseteq Dⁿ`。
    - 为每个 n 元函数 `f` 指定 `D` 上的一个 n 元运算 `f_I: Dⁿ → D`。

在解释 `I` 下，一个闭式可以被确定为真或假。
- `∀x A(x)` 为真，当且仅当对于 `D` 中**所有**元素 `d`，`A(d)` 为真。
- `∃x A(x)` 为真，当且仅当在 `D` 中**至少存在一个**元素 `d`，使得 `A(d)` 为真。

### 公式的分类
- **永真式 (Valid Formula / Tautology)**：在**任何**解释下都为真的公式。记作 `⊨ A`。
  - **示例**: `∀x (P(x) ∨ ¬P(x))`
- **永假式 (Contradiction / Unsatisfiable Formula)**：在**任何**解释下都为假的公式。
  - **示例**: `∃x (P(x) ∧ ¬P(x))`
- **可满足式 (Satisfiable Formula)**：**至少存在一个**解释使其为真的公式。
  - **注意**：永真式一定是可满足式。一个公式是永假式，当且仅当它的否定是永真式。

### 代换实例和相关定理
- **代换实例 (Substitution Instance)**：用一个项 `t` 替换公式 `A` 中变元 `x` 的**所有自由出现**，记作 `A[t/x]`。
- **重要约束**：代换必须是**自由的**（free for substitution）。即，项 `t` 中的任何变元在代换后不能被 `A` 中原有的量词所约束。如果发生这种情况（称为**变元捕获**），则代换无效。
  - **示例**：在 `∃y (x > y)` 中，不能用 `y` 替换 `x`。如果替换，会得到 `∃y (y > y)`，原意“存在一个数比 x 小”变成了“存在一个数比自己大”，含义完全改变。
- **相关推理规则**：
    - **全称实例化 (Universal Instantiation, UI)**: 从 `∀x A(x)` 可以推出 `A(c)`，其中 `c` 是论域中的任意常量。
    - **存在泛化 (Existential Generalization, EG)**: 从 `A(c)` 可以推出 `∃x A(x)`。

### 非形式化证明方法
除了形式化的逻辑演算，我们常用以下四种推理规则进行证明：
1.  **UI (Universal Instantiation)**: `∀x A(x) ⊢ A(c)`。如果对所有 x 都成立，那么对某个特定的 c 也成立。
2.  **UG (Universal Generalization)**: `A(c) ⊢ ∀x A(x)`。**限制条件**: `c` 必须是**任意选取**的个体，不能在前提中被特殊指定。
3.  **EI (Existential Instantiation)**: `∃x A(x) ⊢ A(c)`。**限制条件**: `c` 必须是一个**新的**、之前未在证明中使用的常量，代表那个存在的未知个体。
4.  **EG (Existential Generalization)**: `A(c) ⊢ ∃x A(x)`。如果对某个特定的 c 成立，那么至少存在一个 x 使其成立。

### 解释法 (Method of Interpretation)
解释法是用来证明一个公式**不是永真式**或一个推理**无效**的方法。其核心是构造一个**反例 (Counterexample)**。
- **步骤**：
  1.  要证明 `A` 不是永真式，就尝试构造一个使 `A` 为假的解释 `I`。
  2.  要证明 `P₁, P₂, ..., Pₙ ⊢ C` 无效，就尝试构造一个使所有前提 `P₁` 到 `Pₙ` 为真，但结论 `C` 为假的解释 `I`。
  3.  这个解释 `I` 通常包含一个小而简单的论域 `D`（如 `{a, b}`）和在 `D` 上定义的谓词。

### 等价演算 (Equivalence Calculus)
使用谓词逻辑的等价定律来推导和简化公式。除了命题逻辑的所有等价律外，还有涉及量词的等价律：

1.  **量词否定 (De Morgan's Laws for Quantifiers)**:
    - `¬(∀x A(x)) ⇔ ∃x (¬A(x))` (并非所有都满足 ⇔ 存在不满足的)
    - `¬(∃x A(x)) ⇔ ∀x (¬A(x))` (不存在满足的 ⇔ 所有都不满足)
2.  **量词分配律**:
    - `∀x (A(x) ∧ B(x)) ⇔ (∀x A(x)) ∧ (∀x B(x))`
    - `∃x (A(x) ∨ B(x)) ⇔ (∃x A(x)) ∨ (∃x B(x))`
    - **注意**: `∀` 对 `∨` 和 `∃` 对 `∧` 不满足分配律。
3.  **量词辖域收缩与扩张** (设 `B` 中不含 `x` 的自由出现):
    - `∀x (A(x) ∨ B) ⇔ (∀x A(x)) ∨ B`
    - `∃x (A(x) ∨ B) ⇔ (∃x A(x)) ∨ B`
    - `∀x (A(x) ∧ B) ⇔ (∀x A(x)) ∧ B`
    - `∃x (A(x) ∧ B) ⇔ (∃x A(x)) ∧ B`

## 定理

### 换名规则 (Rule of Renaming / Alpha-Conversion)
被约束的变元名称是可以更改的，只要新名称不与公式中已有的其他变元冲突。这个过程称为**换名**或 **α-转换**。
- **规则**: `∀x A(x) ⇔ ∀y A[y/x]`，`∃x A(x) ⇔ ∃y A[y/x]`。
- **条件**: `y` 必须是一个新的变元，在 `A(x)` 中没有自由出现，并且 `A[y/x]` 表示将 `A(x)` 中 `x` 的所有自由出现替换为 `y`。
- **目的**: 避免在推理和代换过程中出现变元捕获的错误。
- **示例**: `∀x ∃y Loves(x, y)` 与 `∀z ∃w Loves(z, w)` 是等价的。

# Reference

- Rosen, Kenneth H. *Discrete Mathematics and Its Applications*. McGraw-Hill Education. (《离散数学及其应用》)
- Stanford Encyclopedia of Philosophy, "Classical Logic" entry.

---
Recommend Links

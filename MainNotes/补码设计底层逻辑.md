> DATA: 2025-06-25 10:09
> TAGS: 
> Course: 
> Author: [ApolloMonasa](https://github.com/ApolloMonasa)
> Pre: [[1.1数制和编码]]
> Next:


# 补码设计底层逻辑

---

### **补码的设计原理**

#### **1. 设计目标：使用加法实现减法**

在计算机硬件中，加法器是核心算术逻辑单元。为了简化电路设计和降低成本，硬件层面通常不实现独立的减法器。因此，计算 `A - B` 的操作需要被转换为加法形式。

数学上，`A - B` 等价于 `A + (-B)`。这个转换将问题聚焦于如何在二进制系统中表示负数（如`-B`），并使其能直接与正数通过加法器运算得到正确的结果。补码（Two's Complement）即是为实现此目标而设计的编码方案。

#### **2. 补码的计算方法**

计算一个整数的补码存在两种方法：一种是操作性的计算技巧，另一种是其数学定义。

##### **方法一：操作法（取反加一）**

此方法常用于手动计算一个负数的补码。
*   **对象**：负数 `N`
*   **步骤**：
    1.  获取 `N` 的绝对值 `|N|`，并写出其在指定位数下的二进制原码表示。
    2.  将此原码的所有位按位取反（0变为1，1变为0）。
    3.  将第2步得到的结果加1。

**示例：在8位系统中计算 -5 的补码**
1.  `+5` 的8位原码为 `0000 0101`。
2.  按位取反后得到 `1111 1010`。
3.  加1后得到 `1111 1011`。

##### **方法二：数学定义法**

此方法揭示了补码的数学本质，其核心是模运算（Modular Arithmetic）。一个`n`位二进制系统可以表示 `2^n` 个不同的值，其运算天然地遵循模 `2^n` 的规则。例如，在8位系统中，`255 + 1` 的结果 `256` (二进制 `1 0000 0000`) 会因为溢出而丢失最高位的 `1`，结果变为 `0000 0000`，这等效于对 `2^8` 取模。

利用这个特性，补码 `[N]_补` 被定义为：
> 在一个`n`位系统中，整数`N`的补码 `[N]_补` 定义如下：
> $$
> [N]_{补} = \begin{cases}
> N & \text{当 } 0 \le N \le 2^{n-1}-1 & \text{(正数和零)} \\
> 2^n + N & \text{当 } -2^{n-1} \le N < 0 & \text{(负数)}
> \end{cases}
> $$

对于负数 `N`，其补码为其在模 `2^n` 意义下的等价值。`2^n + N` 也可写作 `2^n - |N|`。

**示例：在8位系统中计算 -5 的补码**
1.  根据定义，`n=8`, `N=-5`。
2.  `[-5]_补 = 2^8 + (-5) = 256 - 5 = 251`。
3.  将十进制 `251` 转换为8位二进制，结果为 `1111 1011`。

两种方法所得结果一致。

#### **3. 两种方法的数学关联**

操作法（取反加一）是数学定义法的一种快速算法。其等价性可以被证明。
对于一个负数 `N`，令 `B = |N|`，则 `N = -B`。根据数学定义，其补码为 `2^n - B`。
对 `2^n - B` 进行代数变形：
`2^n - B = (2^n - 1) - B + 1`

分析该式：
*   在`n`位二进制中，`2^n - 1` 的值是一个所有位都为`1`的数（例如，n=8时，为 `1111 1111`）。
*   用一个全为`1`的`n`位数去减去另一个`n`位数`B`，其运算结果等效于对`B`的各位**按位取反**。
    例如 (n=8, B=5):
    ```
      1111 1111
    - 0000 0101  (B)
    -----------------
      1111 1010  (B按位取反的结果)
    ```
*   因此，`(2^n - 1) - B` 的操作等价于对 `B` 的原码按位取反。

将此结论代入原式，`2^n - B = (2^n - 1) - B + 1` 就等价于：
**（对B的原码按位取反） + 1**

这证明了“取反加一”的操作法在数学上与 `2^n + N` 的定义是完全等价的。
# Reference


---
Recommend Links

> DATA: 2025-07-10 00:17
> TAGS:[[数据结构]]
> Course: #比特数据结构 
> Author: [ApolloMonasa](https://github.com/ApolloMonasa)
> Pre: [[1.1 时间复杂度]]
> Next:[[1.3 空间复杂度]]

# 1.2 均摊时间复杂度
## 引入

在[[算法复杂度分析]]中，我们通常关心**最坏情况时间复杂度 (Worst-Case Complexity)**。然而，对于某些数据结构，最坏情况可能很少发生，且其高昂的成本发生后，会为后续大量操作带来便利。如果一直用最坏情况来衡量，会过分高估算法的真实性能。

**均摊分析 (Amortized Analysis)** 应运而生。它不是分析单次操作，而是分析一个**操作序列**的总成本，然后将总成本“均摊”到每一次操作上，得出一个更具代表性的平均成本。

> [!IMPORTANT] 核心区别
> - **最坏情况分析**：给出了**任何单次操作**成本的上限。
> - **均摊分析**：给出了**一系列操作中，平均每次操作**成本的上限。它保证了整个序列的总成本不会超过 `(均摊成本) * (操作次数)`。

## 原理

均摊分析的核心原理是“**平摊**”或“**储蓄**”。

- 一系列操作中，大部分操作的**实际成本 (Actual Cost)** 很低（“廉价操作”），少数操作的实际成本很高（“昂贵操作”）。
- 我们可以为每次操作设定一个**均摊成本 (Amortized Cost)**。
- 对于廉价操作，其均摊成本会高于实际成本，多出的部分就像存钱一样，可以“**积攒信用 (Credit)**”。
- 当昂贵操作发生时，它高昂的实际成本可以用之前积攒的信用“**支付**”，从而使其均摊成本保持在一个较低的水平。

## 内容：三种分析方法

有三种常用的均摊分析方法，它们从不同角度实现了上述原理。

1.  **聚合分析 (Aggregate Analysis)**: 直接求出整个序列的总成本，再除以操作次数。
2.  **记账分析 (Accounting Method)**: 引入“信用”或“银行账户”模型，为不同操作设定不同的收费（均摊成本），保证账户余额永不为负。
3.  **势能分析 (Potential Method)**: 最为通用和强大的方法，将“积攒的信用”物化为一个与数据结构状态相关的“势能函数 `Φ`”，通过势能的变化来计算均摊成本。

---

## 示例：动态数组的扩容分析

我们以经典的**动态数组 `append` 操作**为例，演示这三种分析方法。
**场景**:
- 一个动态数组，从空开始。
- 每次 `append` 一个元素。
- 如果数组满了，就分配一个**两倍**于原大小的新数组，并将所有旧元素复制过去。

### 1. 聚合分析法 (Aggregate Analysis)

我们分析一个包含 `n` 次 `append` 操作的序列。
- **实际成本**:
    - 普通插入：成本为 `1`。
    - 扩容插入：假设当前大小为 `m`，则需要复制 `m` 个元素，再插入 `1` 个新元素，成本为 `m+1`。
- **总成本计算**:
    - `n` 次操作必然包含 `n` 次基本插入，成本为 `n`。
    - 扩容发生在数组大小为 `2^k` 时 (`k=0, 1, 2, ...`)。假设 `n` 次操作后，数组大小为 `2^m` (`2^(m-1) < n ≤ 2^m`)。
    - 扩容的总成本为：`1 + 2 + 4 + ... + 2^(m-1)` (在大小为1, 2, 4...时扩容)。
    - 这是一个等比数列，其和为 `2^m - 1`。因为 `n > 2^(m-1)`，所以 `2n > 2^m`。因此 `2^m - 1 < 2n - 1`。
- **总成本 `T(n)`** = (n次插入) + (总扩容成本) = `n + (2^m - 1) < n + (2n - 1) = 3n - 1`。
- **均摊成本** = `T(n) / n < (3n - 1) / n = 3 - 1/n`。
- **结论**: 每次 `append` 操作的均摊成本为 **O(1)**。

### 2. 记账分析法 (Accounting Method)

我们为每次 `append` 操作设定一个**均摊成本（收费）为 3 个单位**。
- **当 `append` 不触发扩容时**:
    - 实际成本为 `1`。
    - 我们支付 `1` 个单位用于插入。
    - 剩下的 `2` 个单位作为“信用”存起来，与新插入的元素关联。
- **当 `append` 触发扩容时**:
    - 假设数组从大小 `m` 扩容到 `2m`。此时数组中有 `m` 个元素。
    - 这 `m` 个元素，每个都积攒了 `2` 个单位的信用，总信用为 `2m`。
    - 扩容的实际成本是 `m` (复制旧元素) + `1` (插入新元素)。
    - 我们支付本次操作的 `3` 个单位中的 `1` 个用于插入新元素。
    - 我们从积攒的 `2m` 信用中，拿出 `m` 个单位支付复制成本。
    - **分析**: 支付后，我们还剩下 `m` 个单位的信用。这 `m` 个单位信用可以分配给新数组中的前 `m` 个元素（每个1单位）。但为了保持策略一致性，我们可以看到，我们用`m`个单位信用就支付了复制，银行账户依然是正的。
- **结论**: 只要每次操作收费 3，我们的“银行账户”就永远不会透支。因此，均摊成本为 **O(1)**。

### 3. 势能分析法 (Potential Method)

这是最严谨的方法。
- 定义一个**势能函数 `Φ`**: `Φ(D_i) = 2 * size(D_i) - capacity(D_i)`
    - `D_i` 是第 `i` 次操作后的数据结构状态。
    - `size` 是元素数量，`capacity` 是数组容量。
    - 初始时，`Φ(D_0) = 0`。势能永远非负。
- **均摊成本 `â_i`** 的公式为: `â_i = c_i + Φ(D_i) - Φ(D_{i-1})`
    - `c_i` 是第 `i` 次操作的实际成本。
- **情况一：不扩容**
    - `c_i = 1`。
    - `size(D_i) = size(D_{i-1}) + 1`，`capacity` 不变。
    - `Φ(D_i) - Φ(D_{i-1}) = (2 * size_i - cap) - (2 * size_{i-1} - cap) = 2 * (size_i - size_{i-1}) = 2`。
    - `â_i = 1 + 2 = 3`。
- **情况二：扩容**
    - 假设操作前 `size = capacity = m`。操作后 `size = m+1`, `capacity = 2m`。
    - `c_i = m + 1` (复制`m`个，插入`1`个)。
    - `Φ(D_{i-1}) = 2 * m - m = m`。
    - `Φ(D_i) = 2 * (m+1) - 2m = 2`。
    - `Φ(D_i) - Φ(D_{i-1}) = 2 - m`。
    - `â_i = (m+1) + (2 - m) = 3`。
- **结论**: 在所有情况下，均摊成本都是 3。因此，均摊成本为 **O(1)**。

---

## 扩展示例：带 MULTIPOP 的堆栈操作

考虑一个栈，除了常规的 `PUSH` 和 `POP` 外，还有一个 `MULTIPOP(k)` 操作，它会连续弹出 `k` 个元素。
- `PUSH(S, x)`: 成本为 `1`。
- `POP(S)`: 成本为 `1`。
- `MULTIPOP(S, k)`: 成本为 `min(k, s)`，其中 `s` 是栈大小。最坏情况成本为 `O(n)`。

使用**聚合分析**：
- 一个元素只能被 `PUSH` 一次。
- 一个元素也只能被 `POP` 或 `MULTIPOP` 弹出一次。
- 对于任何一个包含 `n` 次操作的序列，`PUSH` 的总次数最多为 `n`。
- `POP` 和 `MULTIPOP` 的总弹出次数，加起来也不会超过 `PUSH` 的总次数，即最多为 `n`。
- 所以，序列的总成本 `T(n)` ≤ `n` (for PUSH) + `n` (for all pops) = `2n`。
- **均摊成本** = `T(n) / n ≤ 2n / n = 2`。
- **结论**: 即使 `MULTIPOP` 的单次最坏成本是 `O(n)`，其均摊成本也是 **O(1)**。


## Reference
- [[算法导论]] (CLRS), 第17章：均摊分析。
- [OI-Wiki](https://oi-wiki.org/basic/complexity/)
---
Recommend Links

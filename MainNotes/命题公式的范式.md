> DATA: 2025-06-17 10:44
> TAGS: [[离散数学]]
> Course: #离散数学 
> Author: [ApolloMonasa](https://github.com/ApolloMonasa)
> Pre: 


# 命题公式的范式
好的，我们来系统地介绍离散数学中命题公式的范式。这是一个非常核心且实用的概念，尤其在逻辑推理、电路设计和算法分析中至关重要。

### **核心思想**

想象一下，我们有很多种方式来表达同一个数学意思，比如 “$x = 2+2$”、“$x = 1+3$”、“$x=4$”。它们形式不同，但本质相同。在命题逻辑中，同样一个逻辑关系也可以用多种公式表达，例如 `P → Q` 和 `¬P ∨ Q` 在逻辑上是等价的。

**范式（Normal Form）** 就是一种**标准化的公式形式**。任何一个命题公式，都可以通过等价变换化为这种标准形式。这样做的好处是：

1.  **便于判断等价性**：如果两个不同公式的范式相同，那么它们就是等gao'ji价的。
2.  **便于程序处理**：标准化的形式更利于计算机进行自动推理和化简。
3.  **与实际应用结合**：例如，析取范式直接对应于数字电路中的“与非门”或“或非门”实现。

---

### **1. 基础构件**

在定义范式之前，我们需要先定义构成范式的基本“砖块”。

*   **文字（Literal）**: 一个命题变元（如 `P`）或其否定（如 `¬P`）统称为文字。

*   **初等积（Elementary Product）**:
    *   **定义**: 由**有限个文字**通过**合取（AND / ∧）** 联结而成的公式。
    *   **别名**: 也常被称为**小项（Minterm）**。
    *   **要求**: 在一个初等积中，任何一个命题变元和它的否定不能同时出现（否则该项恒为假，如 `P ∧ ¬P`）。
    *   **示例**:
        *   `P` (单个文字也是初等积)
        *   `¬Q ∧ R`
        *   `P ∧ ¬Q ∧ R`
        *   `P ∧ Q ∧ P` (这是初等积，但可以化简为 `P ∧ Q`)
        *   `P ∧ ¬P ∧ Q` (这不是一个“有意义”的初等积，因为它永假)

*   **初等和（Elementary Sum）**:
    *   **定义**: 由**有限个文字**通过**析取（OR / ∨）** 联结而成的公式。
    *   **别名**: 也常被称为**大项（Maxterm）**。
    *   **要求**: 在一个初等和中，任何一个命题变元和它的否定不能同时出现（否则该项恒为真，如 `P ∨ ¬P`）。
    *   **示例**:
        *   `¬P` (单个文字也是初等和)
        *   `Q ∨ R`
        *   `¬P ∨ Q ∨ ¬R`
        *   `P ∨ ¬P ∨ Q` (这不是一个“有意义”的初等和，因为它永真)

---

### **2. 两种核心范式**

有了基础构件，我们就可以搭建两种主要的范式了。

#### **析取范式（Disjunctive Normal Form, DNF）**

*   **定义**: 由**有限个初等积**通过**析取（OR / ∨）** 联结而成的公式。
*   **结构**: `(积) ∨ (积) ∨ ... ∨ (积)`，可以理解为“**积之和**”（Sum of Products）。
*   **示例**:
    *   `P` (单个初等积也是析取范式)
    *   `(P ∧ Q) ∨ (¬P ∧ R)`
    *   `(P ∧ ¬Q ∧ R) ∨ (¬P ∧ ¬Q)`
    *   `P ∨ Q` (可以看作 `(P) ∨ (Q)`)

#### **合取范式（Conjunctive Normal Form, CNF）**

*   **定义**: 由**有限个初等和**通过**合取（AND / ∧）** 联结而成的公式。
*   **结构**: `(和) ∧ (和) ∧ ... ∧ (和)`，可以理解为“**和之积**”（Product of Sums）。
*   **示例**:
    *   `P` (单个初等和也是合取范式)
    *   `(P ∨ Q) ∧ (¬P ∨ R)`
    *   `(P ∨ ¬Q ∨ R) ∧ (¬P ∨ ¬Q)`
    *   `P ∧ Q` (可以看作 `(P) ∧ (Q)`)

---

### **3. 范式存在定理**

这是一个非常重要的理论保证。

**定理内容**: 对于**任意一个**命题公式，只要它**不是永真式（Tautology）或永假式（Contradiction）**，那么一定**存在**一个与它等价的析取范式和一个与它等价的合取范式。

*   **永真式**: 其析取范式为 `True` (或 `P ∨ ¬P`)，合取范式不存在（或定义为空集）。
*   **永假式**: 其合取范式为 `False` (或 `P ∧ ¬P`)，析取范式不存在（或定义为空集）。

这个定理告诉我们，范式是一种普遍的表达形式，几乎所有公式都能转换过去。

---

### **4. 求范式的技巧**

求范式主要有两种方法：**真值表法** 和 **等价演算法**。

#### **方法一：真值表法 (最直观，直接求出主范式)**

这种方法直接从公式的真值表入手，可以一步到位求出最特殊的范式——**主范式**。

*   **主析取范式 (Principal DNF)**:
    1.  列出公式的真值表。
    2.  找出所有使公式结果为 **真 (True / 1)** 的行。
    3.  对于每一行，写出其对应的**小项（初等积）**：如果该行某个变量为 `1`，则在小项中写 `P`；如果为 `0`，则写 `¬P`。
    4.  将所有这些小项用 **析取（∨）** 连接起来，就得到了主析取范式。

*   **主合取范式 (Principal CNF)**:
    1.  列出公式的真值表。
    2.  找出所有使公式结果为 **假 (False / 0)** 的行。
    3.  对于每一行，写出其对应的**大项（初等和）**：如果该行某个变量为 `0`，则在大项中写 `P`；如果为 `1`，则写 `¬P`。（**注意：这里与小项的规则相反**）
    4.  将所有这些大项用 **合取（∧）** 连接起来，就得到了主合取范式。

#### **方法二：等价演算法 (代数方法)**

这种方法利用逻辑等价定律，通过代数推导得到范式。

**核心步骤**:
1.  **去蕴含**: 消去 `→` 和 `↔`。
    *   `A → B ⇔ ¬A ∨ B`
    *   `A ↔ B ⇔ (A → B) ∧ (B → A) ⇔ (¬A ∨ B) ∧ (¬B ∨ A)`
2.  **内移否定**: 使用**德摩根定律**将否定符号 `¬` 内移，直到它只作用于单个命题变元。
    *   `¬(A ∧ B) ⇔ ¬A ∨ ¬B`
    *   `¬(A ∨ B) ⇔ ¬A ∧ ¬B`
    *   以及**双重否定律**: `¬¬A ⇔ A`
3.  **分配**: 使用**分配律**形成最终范式。
    *   **求析取范式 (DNF)**: 将 `∧` 分配到 `∨` 上，即 `A ∧ (B ∨ C) ⇔ (A ∧ B) ∨ (A ∧ C)`。最终目标是形成 **(积) ∨ (积)** 的形式。
    *   **求合取范式 (CNF)**: 将 `∨` 分配到 `∧` 上，即 `A ∨ (B ∧ C) ⇔ (A ∨ B) ∧ (A ∨ C)`。最终目标是形成 **(和) ∧ (和)** 的形式。

---

### **5. 例题**

求公式 `F = (P → Q) ∧ ¬P` 的析取范式和合取范式。

#### **解法一：真值表法**

1.  **列出真值表**:

| P | Q | P → Q | ¬P | **F = (P → Q) ∧ ¬P** |
| :-- | :-- | :------ | :--- | :--------------------- |
| 1 | 1 | 1 | 0 | **0** |
| 1 | 0 | 0 | 0 | **0** |
| 0 | 1 | 1 | 1 | **1** |
| 0 | 0 | 1 | 1 | **1** |

2.  **求主析取范式 (DNF)**:
    *   找出 `F` 为 `1` 的行：第3行和第4行。
    *   第3行 `(P=0, Q=1)` 对应的小项是 `¬P ∧ Q`。
    *   第4行 `(P=0, Q=0)` 对应的小项是 `¬P ∧ ¬Q`。
    *   将它们用 `∨` 连接：
        **主析取范式: `(¬P ∧ Q) ∨ (¬P ∧ ¬Q)`**
        (可以进一步化简为 `¬P ∧ (Q ∨ ¬Q) ⇔ ¬P ∧ True ⇔ ¬P`，这说明原公式与 `¬P` 等价)

3.  **求主合取范式 (CNF)**:
    *   找出 `F` 为 `0` 的行：第1行和第2行。
    *   第1行 `(P=1, Q=1)` 对应的大项是 `¬P ∨ ¬Q`。(注意规则相反)
    *   第2行 `(P=1, Q=0)` 对应的大项是 `¬P ∨ Q`。
    *   将它们用 `∧` 连接：
        **主合取范式: `(¬P ∨ ¬Q) ∧ (¬P ∨ Q)`**
        (可以进一步化简为 `¬P ∨ (¬Q ∧ Q) ⇔ ¬P ∨ False ⇔ ¬P`，同样验证了等价性)

#### **解法二：等价演算法**

`F = (P → Q) ∧ ¬P`

1.  **去蕴含**:
    `F ⇔ (¬P ∨ Q) ∧ ¬P`

2.  **求析取范式 (DNF)**:
    *   我们现在有 `(¬P ∨ Q) ∧ ¬P`。使用分配律，将 `∧ ¬P` 分配进去。
    *   `F ⇔ (¬P ∧ ¬P) ∨ (Q ∧ ¬P)`
    *   根据幂等律 `A ∧ A ⇔ A`，简化得：
    *   `F ⇔ ¬P ∨ (Q ∧ ¬P)`
    *   再用吸收律 `A ∨ (B ∧ A) ⇔ A`:
    *   `F ⇔ ¬P`
    *   `¬P` 本身就是一个初等积，因此它也是一个析取范式。
        **析取范式: `¬P`**

3.  **求合取范式 (CNF)**:
    *   我们从 `(¬P ∨ Q) ∧ ¬P` 开始。
    *   这个形式已经是 `(初等和) ∧ (初等和)` 的形式了（`¬P`可以看作一个单文字的初等和）。
    *   所以，它本身就是一个合取范式。
        **合取范式: `(¬P ∨ Q) ∧ ¬P`**

**结果对比**:
*   **析取范式**: 真值表法得到 `(¬P ∧ Q) ∨ (¬P ∧ ¬Q)`，等价演算法得到 `¬P`。两者逻辑等价。
*   **合取范式**: 真值表法得到 `(¬P ∨ ¬Q) ∧ (¬P ∨ Q)`，等价演算法得到 `(¬P ∨ Q) ∧ ¬P`。两者也逻辑等价。

这说明，一个公式的范式不唯一，但其**主范式**是唯一的（在不考虑变元顺序的情况下）。等价演算法通常能得到更简洁的范式，而真值表法能直接得到标准的、唯一的主范式。

# Reference


---
Recommend Links
